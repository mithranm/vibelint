# vibelint Report

*Generated on: 2025-04-11 08:34:01*

**Project(s):** vibelint

**Paths analyzed:** /Users/mithranmohanraj/Documents/vibelint

## Table of Contents

1. [Summary](#summary)
2. [Linting Results](#linting-results)
3. [Namespace Structure](#namespace-structure)
4. [Namespace Collisions](#namespace-collisions)
5. [File Contents](#file-contents)

## Summary

| Metric | Count |
|--------|-------|
| Files analyzed | 17 |
| Files with errors | 1 |
| Files with warnings | 0 |
| Hard namespace collisions | 4 |
| Soft namespace collisions | 6 |

## Linting Results

| File | Errors | Warnings |
|------|--------|----------|
| `/Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/ValidationResult.py` | Docstring should include the relative path: vibelint/validators/ValidationResult.py | None |

## Namespace Structure

```
<rich.tree.Tree object at 0x104c24610>
```

## Namespace Collisions

### Hard Collisions

These collisions can break Python imports:

| Name | Path 1 | Path 2 |
|------|--------|--------|
| `ValidationResult` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/ValidationResult.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/__init__.py |
| `ValidationResult` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/__init__.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/__init__.py |
| `ValidationResult` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/ValidationResult.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/__init__.py |
| `ValidationResult` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/ValidationResult.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/__init__.py |

### Soft Collisions

These don't break Python but may confuse humans and LLMs:

| Name | Path 1 | Path 2 |
|------|--------|--------|
| `console` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/cli.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/report.py |
| `console` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/cli.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/lint.py |
| `console` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/report.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/lint.py |
| `ValidationResult` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/encoding.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/shebang.py |
| `ValidationResult` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/encoding.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/docstring.py |
| `ValidationResult` | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/shebang.py | /Users/mithranmohanraj/Documents/vibelint/src/vibelint/validators/docstring.py |

## File Contents

Files are ordered by their position in the namespace hierarchy.

### setup.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Setup script for vibelint.

setup.py
"""

from setuptools import setup

if __name__ == "__main__":
    setup()

```

### src/vibelint/cli.py

```python
#!/usr/bin/env python3
"""
Command-line interface for vibelint.

vibelint/cli.py
"""

import sys
from pathlib import Path
from typing import List

import click
from rich.console import Console
from rich.table import Table

from .lint import LintRunner
from .config import load_config
from .namespace import (
    build_namespace_tree_representation, 
    get_namespace_collisions_str, 
    detect_namespace_collisions,
    detect_soft_member_collisions
)
from .report import generate_markdown_report


console = Console()

@click.group()
@click.version_option()
def cli():
    """vibelint - A linting tool to make Python codebases more LLM-friendly."""
    pass


@cli.command()
@click.option(
    "--path",
    type=click.Path(exists=True, file_okay=False, dir_okay=True, readable=True),
    default=".",
    help="Path to directory to analyze (default: current directory)",
)
@click.option(
    "--check-only",
    is_flag=True,
    help="Check for violations without fixing them",
)
@click.option(
    "--yes",
    is_flag=True,
    help="Skip confirmation for large directories",
)
@click.option(
    "--include-vcs-hooks",
    is_flag=True,
    help="Include version control hooks in analysis",
)
@click.argument("paths", nargs=-1, type=click.Path(exists=True, readable=True))
def headers(
    path: str,
    check_only: bool,
    yes: bool,
    include_vcs_hooks: bool,
    paths: List[str],
):
    """Lint and fix Python module headers.

    If PATHS are provided, only those files/directories will be analyzed.
    Otherwise, all Python files under PATH will be analyzed.
    """
    root_path = Path(path).resolve()
    config = load_config(root_path)

    # Use provided paths if available, otherwise use the root path
    target_paths = [Path(p).resolve() for p in paths] if paths else [root_path]

    lint_runner = LintRunner(
        config=config,
        check_only=check_only,
        skip_confirmation=yes,
        include_vcs_hooks=include_vcs_hooks,
    )

    exit_code = lint_runner.run(target_paths)
    sys.exit(exit_code)


@cli.command()
@click.option(
    "--path",
    type=click.Path(exists=True, file_okay=False, dir_okay=True, readable=True),
    default=".",
    help="Path to directory to analyze (default: current directory)",
)
@click.option(
    "--include-vcs-hooks",
    is_flag=True,
    help="Include version control hooks in analysis",
)
@click.option(
    "--show-collisions",
    is_flag=True,
    help="Additionally show namespace collisions",
)
@click.argument("paths", nargs=-1, type=click.Path(exists=True, readable=True))
def namespace(
    path: str,
    include_vcs_hooks: bool,
    show_collisions: bool,
    paths: List[str],
):
    """Visualize the namespace tree of a Python project.
    
    Displays the hierarchical structure of modules and their members.
    
    If PATHS are provided, only those files/directories will be analyzed.
    Otherwise, all Python files under PATH will be analyzed.
    """
    root_path = Path(path).resolve()
    config = load_config(root_path)

    # Use provided paths if available, otherwise use the root path
    target_paths = [Path(p).resolve() for p in paths] if paths else [root_path]

    # Show namespace tree
    tree = build_namespace_tree_representation(target_paths, config)
    console.print(tree)
    
    # Optionally show collisions
    if show_collisions:
        collision_str = get_namespace_collisions_str(target_paths, config)
        if collision_str:
            console.print(collision_str)


@cli.command()
@click.option(
    "--path",
    type=click.Path(exists=True, file_okay=False, dir_okay=True, readable=True),
    default=".",
    help="Path to directory to analyze (default: current directory)",
)
@click.option(
    "--ignore-inheritance",
    is_flag=True,
    help="Don't consider inheritance when detecting soft collisions",
)
@click.option(
    "--soft-only",
    is_flag=True,
    help="Only show soft collisions (member names reused in unrelated modules)",
)
@click.option(
    "--hard-only",
    is_flag=True,
    help="Only show hard collisions (namespace conflicts)",
)
@click.argument("paths", nargs=-1, type=click.Path(exists=True, readable=True))
def collisions(
    path: str,
    ignore_inheritance: bool,
    soft_only: bool,
    hard_only: bool,
    paths: List[str],
):
    """Detect namespace collisions in Python code.
    
    Finds both hard collisions (naming conflicts that break Python) and soft collisions
    (member names that appear in unrelated modules and may confuse humans or LLMs).
    
    If PATHS are provided, only those files/directories will be analyzed.
    Otherwise, all Python files under PATH will be analyzed.
    """
    root_path = Path(path).resolve()
    config = load_config(root_path)

    # Use provided paths if available, otherwise use the root path
    target_paths = [Path(p).resolve() for p in paths] if paths else [root_path]
    
    console.print("[bold]Checking for namespace collisions...[/bold]")
    
    # Detect collisions
    hard_collisions = [] if soft_only else detect_namespace_collisions(target_paths, config)
    soft_collisions = [] if hard_only else detect_soft_member_collisions(
        target_paths, config, use_inheritance_check=not ignore_inheritance
    )
    
    # Create summary table
    table = Table(title="Collision Results Summary")
    table.add_column("Type", style="cyan")
    table.add_column("Count", style="magenta")
    
    table.add_row("Hard Collisions", str(len(hard_collisions)))
    table.add_row("Soft Collisions", str(len(soft_collisions)))
    table.add_row("Total", str(len(hard_collisions) + len(soft_collisions)))
    
    console.print(table)
    
    # Display detailed results
    if not hard_collisions and not soft_collisions:
        console.print("[green]âœ“ No namespace collisions detected[/green]")
        sys.exit(0)
    
    # Show detailed reports
    if hard_collisions:
        console.print("\n[bold red]Hard Collisions:[/bold red]")
        console.print("[dim](These can break Python imports)[/dim]")
        for collision in hard_collisions:
            console.print(
                f"- [red]'{collision.name}'[/red] in [cyan]{collision.path1}[/cyan] and [cyan]{collision.path2}[/cyan]"
            )
            
    if soft_collisions:
        console.print("\n[bold yellow]Soft Collisions:[/bold yellow]")
        console.print("[dim](These don't break Python but may confuse humans and LLMs)[/dim]")
        for collision in soft_collisions:
            console.print(
                f"- [yellow]'{collision.name}'[/yellow] in [cyan]{collision.path1}[/cyan] and [cyan]{collision.path2}[/cyan]"
            )
    
    # Exit with error code if hard collisions found (soft collisions are just warnings)
    sys.exit(1 if hard_collisions else 0)


@cli.command()
@click.option(
    "--path",
    type=click.Path(exists=True, file_okay=False, dir_okay=True, readable=True),
    default=".",
    help="Path to directory to analyze (default: current directory)",
)
@click.option(
    "-o", "--output",
    type=click.Path(file_okay=False, dir_okay=True, writable=True),
    default="./vibelint_reports",
    help="Output directory for the report (default: ./vibelint_reports)",
)
@click.option(
    "--check-only",
    is_flag=True,
    help="Only report issues without suggesting fixes",
)
@click.option(
    "--include-vcs-hooks",
    is_flag=True,
    help="Include version control hooks in analysis",
)
@click.option(
    "--ignore-inheritance",
    is_flag=True,
    help="Don't consider inheritance when detecting soft collisions",
)
@click.argument("paths", nargs=-1, type=click.Path(exists=True, readable=True))
def report(
    path: str,
    output: str,
    check_only: bool,
    include_vcs_hooks: bool,
    ignore_inheritance: bool,
    paths: List[str],
):
    """Generate a comprehensive markdown report of the codebase.
    
    The report includes linting errors, namespace structure, collisions, 
    and file contents organized by namespace hierarchy.
    
    If PATHS are provided, only those files/directories will be analyzed.
    Otherwise, all Python files under PATH will be analyzed.
    """
    root_path = Path(path).resolve()
    output_path = Path(output).resolve()
    
    # Create output directory if it doesn't exist
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Load configuration
    config = load_config(root_path)
    
    # Use provided paths if available, otherwise use the root path
    target_paths = [Path(p).resolve() for p in paths] if paths else [root_path]
    
    console.print(f"[bold]Generating comprehensive report for {len(target_paths)} path(s)...[/bold]")
    
    # Generate the report
    report_path = generate_markdown_report(
        target_paths=target_paths,
        output_dir=output_path,
        config=config,
        check_only=check_only,
        include_vcs_hooks=include_vcs_hooks,
        ignore_inheritance=ignore_inheritance
    )
    
    console.print(f"[green]âœ“ Report generated successfully at:[/green] {report_path}")
    return 0


def main():
    """Entry point for the CLI."""
    cli()


if __name__ == "__main__":
    main()

```

### src/vibelint/config.py

```python
"""
Configuration handling for vibelint.

vibelint/config.py
"""

import sys
import json
from pathlib import Path
from typing import Dict, Any, Optional
import copy

# Import tomllib for Python 3.11+, fallback to tomli for earlier versions
if sys.version_info >= (3, 11):
    import tomllib
else:
    import tomli as tomllib


DEFAULT_CONFIG = {
    "package_root": "",
    "allowed_shebangs": ["#!/usr/bin/env python3"],
    "docstring_regex": r"^[A-Z].+\.$",
    "include_globs": ["**/*.py"],
    "exclude_globs": [
        "**/tests/**",
        "**/migrations/**",
        "**/site-packages/**",
        "**/dist-packages/**",
    ],
    "large_dir_threshold": 500,
}


def find_pyproject_toml(directory: Path) -> Optional[Path]:
    """
    Find the pyproject.toml file by traversing up from the given directory.

    vibelint/config.py
    """
    current = directory.absolute()
    while current != current.parent:
        pyproject_path = current / "pyproject.toml"
        if pyproject_path.exists():
            return pyproject_path
        current = current.parent
    return None


def find_vibelint_config_json(directory: Path) -> Optional[Path]:
    """
    Find the .vibelintconfig.json file by traversing up from the given directory.
    
    Args:
        directory: Directory to start searching from
        
    Returns:
        Path to .vibelintconfig.json if found, None otherwise
    """
    current = directory.absolute()
    while current != current.parent:
        config_path = current / ".vibelintconfig.json"
        if config_path.exists():
            return config_path
        current = current.parent
    return None


def load_user_config() -> Dict[str, Any]:
    """
    Load user configuration from ~/.config/vibelint/config.toml if it exists.

    vibelint/config.py
    """
    config_path = Path.home() / ".config" / "vibelint" / "config.toml"
    if not config_path.exists():
        return {}

    try:
        with open(config_path, "rb") as f:
            user_config = tomllib.load(f)
        return user_config.get("tool", {}).get("vibelint", {})
    except (tomllib.TOMLDecodeError, OSError):
        return {}


def load_json_config(config_path: Path) -> Dict[str, Any]:
    """
    Load configuration from a JSON file.
    
    Args:
        config_path: Path to the JSON config file
        
    Returns:
        Dictionary with configuration values
    """
    try:
        with open(config_path, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, OSError) as e:
        print(f"Warning: Error loading {config_path}: {str(e)}", file=sys.stderr)
        return {}


def load_project_config(directory: Path) -> Dict[str, Any]:
    """
    Load project configuration from pyproject.toml or .vibelintconfig.json.

    vibelint/config.py
    """
    # Try to load from pyproject.toml first
    pyproject_path = find_pyproject_toml(directory)
    if pyproject_path:
        try:
            with open(pyproject_path, "rb") as f:
                pyproject_toml = tomllib.load(f)
            if "tool" in pyproject_toml and "vibelint" in pyproject_toml["tool"]:
                return pyproject_toml["tool"]["vibelint"]
        except (tomllib.TOMLDecodeError, OSError) as e:
            print(f"Warning: Error loading {pyproject_path}: {str(e)}", file=sys.stderr)
    
    # If no pyproject.toml or no vibelint section, try .vibelintconfig.json
    json_config_path = find_vibelint_config_json(directory)
    if json_config_path:
        json_config = load_json_config(json_config_path)
        if json_config:
            return json_config
    
    # Return empty dict if no config found
    return {}


def load_config(directory: Path) -> Dict[str, Any]:
    """
    Load configuration by merging default, user, and project configurations.

    vibelint/config.py
    """
    config = copy.deepcopy(DEFAULT_CONFIG)
    user_config = load_user_config()
    project_config = load_project_config(directory)

    # Update with user config first, then project config (project has higher precedence)
    config.update(user_config)
    config.update(project_config)

    return config

```

### src/vibelint/lint.py

```python
"""
Core linting functionality for vibelint.

vibelint/lint.py
"""

import re
from pathlib import Path
from typing import Dict, List, Any
from concurrent.futures import ThreadPoolExecutor
import fnmatch

import click
from rich.console import Console
from rich.table import Table
from rich.progress import (
    Progress,
    SpinnerColumn,
    TextColumn,
    BarColumn,
    TaskProgressColumn,
)

from .validators.shebang import validate_shebang, fix_shebang
from .validators.encoding import validate_encoding_cookie, fix_encoding_cookie
from .validators.docstring import validate_module_docstring, fix_module_docstring


console = Console()
testcollision = "test"

class LintResult:
    """
    Class to store the result of a linting operation.

    vibelint/lint.py
    """

    def __init__(self):
        self.file_path: Path = Path()
        self.errors: List[str] = []
        self.warnings: List[str] = []
        self.fixed: bool = False

    @property
    def has_issues(self) -> bool:
        """Check if the result has any errors or warnings."""
        return len(self.errors) > 0 or len(self.warnings) > 0


class LintRunner:
    """
    Runner class for linting operations.

    vibelint/lint.py
    """

    def __init__(
        self,
        config: Dict[str, Any],
        check_only: bool = False,
        skip_confirmation: bool = False,
        include_vcs_hooks: bool = False,
    ):
        self.config = config
        self.check_only = check_only
        self.skip_confirmation = skip_confirmation
        self.include_vcs_hooks = include_vcs_hooks
        self.results: List[LintResult] = []
        self.files_fixed: int = 0
        self.files_with_errors: int = 0
        self.files_with_warnings: int = 0

    def run(self, paths: List[Path]) -> int:
        """Run the linting process on the specified paths."""
        # Get all Python files to check
        python_files = self._collect_python_files(paths)

        if not python_files:
            console.print("[yellow]No Python files found to lint.[/yellow]")
            return 0

        # Check if directory is large and requires confirmation
        if (
            not self.skip_confirmation
            and len(python_files) > self.config["large_dir_threshold"]
        ):
            if not self._confirm_large_directory(len(python_files)):
                console.print("[yellow]Operation cancelled.[/yellow]")
                return 0

        # Process files
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=console,
        ) as progress:
            task = progress.add_task(
                f"Linting {len(python_files)} Python files...", total=len(python_files)
            )

            # Use ThreadPoolExecutor for parallel processing
            with ThreadPoolExecutor() as executor:
                for result in executor.map(self._process_file, python_files):
                    self.results.append(result)
                    progress.advance(task)

        # Update statistics
        for result in self.results:
            if result.fixed:
                self.files_fixed += 1
            if result.errors:
                self.files_with_errors += 1
            elif result.warnings:
                self.files_with_warnings += 1

        # Print summary
        self._print_summary()

        # Determine exit code
        if self.files_with_errors > 0 or (self.check_only and self.files_fixed > 0):
            return 1
        return 0

    def _collect_python_files(self, paths: List[Path]) -> List[Path]:
        """Collect all Python files to lint."""
        python_files: List[Path] = []

        for path in paths:
            if path.is_file() and path.suffix == ".py":
                python_files.append(path)
            elif path.is_dir():
                for include_glob in self.config["include_globs"]:
                    # Generate pattern-matched paths
                    matched_files = path.glob(include_glob)
                    for file_path in matched_files:
                        # Skip if it's not a file or not a Python file
                        if not file_path.is_file() or file_path.suffix != ".py":
                            continue

                        # Skip VCS directories unless explicitly included
                        if not self.include_vcs_hooks and any(
                            part.startswith(".") and part in {".git", ".hg", ".svn"}
                            for part in file_path.parts
                        ):
                            continue

                        # Check exclude patterns
                        if any(
                            fnmatch.fnmatch(str(file_path), str(path / exclude_glob))
                            for exclude_glob in self.config["exclude_globs"]
                        ):
                            continue

                        python_files.append(file_path)

        return python_files

    def _confirm_large_directory(self, file_count: int) -> bool:
        """Ask for confirmation when processing a large directory."""
        console.print(
            f"[yellow]Warning:[/yellow] Found {file_count} Python files to lint, which exceeds the "
            f"large_dir_threshold of {self.config['large_dir_threshold']}."
        )
        return click.confirm("Do you want to continue?", default=True)

    def _process_file(self, file_path: Path) -> LintResult:
        """Process a single Python file."""
        result = LintResult()
        result.file_path = file_path

        try:
            # Read file content
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()

            # Create a copy of the content that we'll modify if fixes are needed
            new_content = content

            # Apply validations
            is_script = (
                re.search(r"if\s+__name__\s*==\s*['\"]__main__['\"]", content)
                is not None
            )
            package_root = self.config["package_root"]
            relative_path = str(file_path)

            # If package_root is specified, compute the relative path
            if package_root:
                try:
                    relative_path = str(file_path.relative_to(package_root))
                except ValueError:
                    # File is not within package_root
                    pass

            # Validate shebang
            shebang_result = validate_shebang(
                content, is_script, self.config["allowed_shebangs"]
            )
            if shebang_result.has_issues():
                result.errors.extend(shebang_result.errors)
                result.warnings.extend(shebang_result.warnings)
                if not self.check_only:
                    new_content = fix_shebang(
                        new_content,
                        shebang_result,
                        is_script,
                        self.config["allowed_shebangs"][0],
                    )

            # Validate encoding cookie
            encoding_result = validate_encoding_cookie(content)
            if encoding_result.has_issues():
                result.errors.extend(encoding_result.errors)
                result.warnings.extend(encoding_result.warnings)
                if not self.check_only:
                    new_content = fix_encoding_cookie(new_content, encoding_result)

            # Validate module docstring
            docstring_result = validate_module_docstring(
                content, relative_path, self.config["docstring_regex"]
            )
            if docstring_result.has_issues():
                result.errors.extend(docstring_result.errors)
                result.warnings.extend(docstring_result.warnings)
                if not self.check_only:
                    new_content = fix_module_docstring(
                        new_content, docstring_result, relative_path
                    )

            # Apply fixes if necessary
            if new_content != content and not self.check_only:
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(new_content)
                result.fixed = True

        except Exception as e:
            result.errors.append(f"Error processing file: {str(e)}")

        return result

    def _print_summary(self):
        """Print a summary of the linting operation."""
        table = Table(title="vibelint Results Summary")
        table.add_column("Metric", style="cyan")
        table.add_column("Count", style="green")

        table.add_row("Files processed", str(len(self.results)))
        table.add_row("Files fixed", str(self.files_fixed))
        table.add_row(
            "Files with errors",
            str(self.files_with_errors),
            style="red" if self.files_with_errors else "green",
        )
        table.add_row(
            "Files with warnings",
            str(self.files_with_warnings),
            style="yellow" if self.files_with_warnings else "green",
        )

        console.print(table)

        # Print files with issues
        if self.files_with_errors > 0 or self.files_with_warnings > 0:
            console.print("\n[bold]Files with issues:[/bold]")

            for result in self.results:
                if result.has_issues:
                    status = (
                        "[red]ERROR[/red]"
                        if result.errors
                        else "[yellow]WARNING[/yellow]"
                    )
                    console.print(f"{status} {result.file_path}")

                    for error in result.errors:
                        console.print(f"  - [red]{error}[/red]")
                    for warning in result.warnings:
                        console.print(f"  - [yellow]{warning}[/yellow]")


def lint_files(
    paths: List[Path],
    config: Dict[str, Any],
    check_only: bool = False,
    skip_confirmation: bool = False,
    include_vcs_hooks: bool = False,
) -> int:
    """
    Lint Python files.

    vibelint/lint.py
    """
    runner = LintRunner(
        config=config,
        check_only=check_only,
        skip_confirmation=skip_confirmation,
        include_vcs_hooks=include_vcs_hooks,
    )
    return runner.run(paths)

```

### src/vibelint/namespace.py

```python
"""
Namespace representation and collision detection for vibelint.

vibelint/namespace.py
"""

import os
import ast
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
import fnmatch

from rich.tree import Tree
from rich.console import Console


class CollisionType:
    """Enum-like class for collision types."""
    HARD = "hard"  # Name conflicts that break Python imports
    SOFT = "soft"  # Same name in different modules, potentially confusing


class NamespaceCollision:
    """
    Class to store information about a namespace collision.

    vibelint/namespace.py
    """

    def __init__(self, name: str, path1: Path, path2: Path, collision_type: str = CollisionType.HARD):
        self.name = name
        self.path1 = path1
        self.path2 = path2
        self.collision_type = collision_type

    def __str__(self) -> str:
        type_str = "Hard" if self.collision_type == CollisionType.HARD else "Soft"
        return f"{type_str} collision: '{self.name}' in {self.path1} and {self.path2}"


class ClassInheritanceTracker:
    """Track inheritance relationships between classes to determine if name reuse is legitimate."""
    
    def __init__(self):
        self.inheritance_map: Dict[str, List[str]] = {}  # class -> parent classes
        self.class_locations: Dict[str, Path] = {}  # Fully qualified class name -> file path
    
    def add_class(self, class_name: str, parent_classes: List[str], file_path: Path, module_path: List[str]) -> None:
        """Add a class and its inheritance information."""
        qualified_name = ".".join([*module_path, class_name])
        
        if qualified_name not in self.inheritance_map:
            self.inheritance_map[qualified_name] = []
            self.class_locations[qualified_name] = file_path
        
        for parent in parent_classes:
            self.inheritance_map[qualified_name].append(parent)
    
    def is_related_through_inheritance(self, class1: str, class2: str) -> bool:
        """Check if two classes are related through inheritance."""
        if class1 == class2:
            return True
            
        # Check if class1 inherits from class2
        if class1 in self.inheritance_map:
            if class2 in self.inheritance_map[class1]:
                return True
            
            # Check recursively through all parent classes
            for parent in self.inheritance_map[class1]:
                if self.is_related_through_inheritance(parent, class2):
                    return True
        
        # Check if class2 inherits from class1
        if class2 in self.inheritance_map:
            if class1 in self.inheritance_map[class2]:
                return True
            
            # Check recursively through all parent classes
            for parent in self.inheritance_map[class2]:
                if self.is_related_through_inheritance(parent, class1):
                    return True
        
        return False


class NamespaceNode:
    """
    Class to represent a node in the namespace tree.

    vibelint/namespace.py
    """

    def __init__(
        self, name: str, path: Optional[Path] = None, is_package: bool = False
    ):
        self.name = name
        self.path = path
        self.is_package = is_package
        self.children: Dict[str, NamespaceNode] = {}
        self.members: Dict[str, Path] = {}  # Stores names defined at this level
        # Track the file path where this node is defined
        self.file_path = path if path and path.is_file() else None

    def add_child(
        self, name: str, path: Path, is_package: bool = False
    ) -> "NamespaceNode":
        """Add a child node to this node."""
        if name not in self.children:
            self.children[name] = NamespaceNode(name, path, is_package)
        return self.children[name]

    def add_member(self, name: str, path: Path) -> None:
        """Add a member (variable, function, class) to this node."""
        self.members[name] = path

    def get_collisions(self) -> List[NamespaceCollision]:
        """Get all namespace collisions in this node and its children."""
        collisions: List[NamespaceCollision] = []

        # Check for collisions between children and members
        for name, path in self.members.items():
            if name in self.children:
                child = self.children[name]
                if child.path is None:
                    continue
                collisions.append(NamespaceCollision(name, path, child.path))

        # Check for collisions in children
        for child in self.children.values():
            collisions.extend(child.get_collisions())

        return collisions

    def to_tree(self, parent_tree: Optional[Tree] = None) -> Tree:
        """Convert this node to a rich.Tree for display."""
        # Create a new tree if this is the root
        if parent_tree is None:
            tree = Tree(f":package: {self.name}" if self.is_package else self.name)
        else:
            # Add this node as a branch to the parent tree
            tree = parent_tree.add(
                f":package: {self.name}" if self.is_package else self.name
            )

        # Add members
        if self.members:
            members_branch = tree.add(":page_facing_up: Members")
            for name in sorted(self.members.keys()):
                members_branch.add(name)

        # Add children
        for name, child in sorted(self.children.items()):
            child.to_tree(tree)

        return tree


def _extract_module_members(file_path: Path) -> List[str]:
    """
    Extract all top-level members from a Python module.

    vibelint/namespace.py
    """
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        members = []
        module = ast.parse(content)

        for node in module.body:
            if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):
                members.append(node.name)
            elif isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        members.append(target.id)

        return members
    except Exception:
        # If we can't parse the file, return an empty list
        return []


def _extract_imports_and_all(file_path: Path) -> Tuple[Dict[str, str], List[str], List[str]]:
    """
    Extract imports and __all__ from a Python module.
    
    Returns:
    - import_map: Dict mapping imported name to its source
    - imported_modules: List of modules imported with 'import module'
    - all_names: List of names in __all__
    """
    import_map = {}
    imported_modules = []
    all_names = []
    
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
            
        module = ast.parse(content)
        
        for node in ast.walk(module):
            # Handle 'from X import Y' statements
            if isinstance(node, ast.ImportFrom):
                module_name = node.module or ""  # Handle 'from . import X'
                for name in node.names:
                    import_name = name.asname or name.name
                    import_source = f"{module_name}.{name.name}" if module_name else name.name
                    import_map[import_name] = import_source
            
            # Handle 'import X' and 'import X.Y' statements
            elif isinstance(node, ast.Import):
                for name in node.names:
                    if name.asname:
                        import_map[name.asname] = name.name
                    else:
                        imported_modules.append(name.name)
                        import_map[name.name.split(".")[-1]] = name.name
            
            # Extract __all__ list
            elif isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id == "__all__":
                        if isinstance(node.value, ast.List):
                            for elt in node.value.elts:
                                if isinstance(elt, ast.Constant) and isinstance(elt.value, str):
                                    all_names.append(elt.value)
                                elif isinstance(elt, ast.Str):  # For Python < 3.8
                                    all_names.append(elt.s)
    
    except Exception:
        # If we can't parse the file, return empty collections
        pass
        
    return import_map, imported_modules, all_names


def _build_namespace_tree(
    paths: List[Path], config: Dict[str, Any], include_vcs_hooks: bool = False
) -> NamespaceNode:
    """
    Build a namespace tree from a list of paths.

    vibelint/namespace.py
    """
    # Create the root node
    root = NamespaceNode("root")

    # Keep track of all Python files
    python_files: List[Path] = []

    # Collect all Python files
    for path in paths:
        if path.is_file() and path.suffix == ".py":
            python_files.append(path)
        elif path.is_dir():
            for include_glob in config["include_globs"]:
                # Generate pattern-matched paths
                matched_files = path.glob(include_glob)
                for file_path in matched_files:
                    # Skip if it's not a file or not a Python file
                    if not file_path.is_file() or file_path.suffix != ".py":
                        continue

                    # Skip VCS directories unless explicitly included
                    if not include_vcs_hooks and any(
                        part.startswith(".") and part in {".git", ".hg", ".svn"}
                        for part in file_path.parts
                    ):
                        continue

                    # Check exclude patterns
                    if any(
                        fnmatch.fnmatch(str(file_path), str(path / exclude_glob))
                        for exclude_glob in config["exclude_globs"]
                    ):
                        continue

                    python_files.append(file_path)

    # Find the common root of all files
    if python_files:
        # Convert to strings for easier manipulation
        file_paths_str = [str(p) for p in python_files]

        # Find common prefix
        common_prefix = os.path.commonpath(file_paths_str)

        # Build the namespace tree
        for file_path in python_files:
            # Get the relative path from the common root
            rel_path = str(file_path).replace(common_prefix, "").lstrip(os.sep)
            parts = rel_path.split(os.sep)

            # The last part is the file name
            file_name = parts[-1]

            # Navigate the tree and add packages/modules
            current = root
            for i, part in enumerate(parts[:-1]):
                # Determine if this directory is a package (contains __init__.py)
                package_path = Path(common_prefix, *parts[: i + 1], "__init__.py")
                is_package = package_path.exists()

                # Add this part to the tree
                current = current.add_child(
                    part, Path(common_prefix, *parts[: i + 1]), is_package
                )

            # Add the file as a module
            module_name = file_name[:-3]  # Remove .py extension
            is_package = module_name == "__init__"

            if is_package:
                # For __init__.py files, the members belong to the parent package
                members = _extract_module_members(file_path)
                for member in members:
                    current.add_member(member, file_path)
            else:
                # Add the module to the tree
                module_node = current.add_child(module_name, file_path)

                # Extract and add members from the module
                members = _extract_module_members(file_path)
                for member in members:
                    module_node.add_member(member, file_path)

    return root


def build_namespace_tree_representation(paths: List[Path], config: Dict[str, Any]) -> Tree:
    """
    Build and return the Rich Tree representation of the namespace without printing it.
    
    vibelint/namespace.py
    """
    # Build the namespace tree
    namespace_tree = _build_namespace_tree(paths, config)
    
    # Create and return the tree representation without printing
    return namespace_tree.to_tree()


def get_namespace_collisions_str(paths: List[Path], config: Dict[str, Any]) -> str:
    """
    Get a formatted string of namespace collisions if any exist.
    
    vibelint/namespace.py
    """
    # Build the namespace tree
    namespace_tree = _build_namespace_tree(paths, config)
    
    # Check for collisions
    collisions = namespace_tree.get_collisions()
    if not collisions:
        return ""
        
    # Format collisions as a string
    console = Console(width=100, record=True)
    console.print("\n[bold red]Namespace Collisions:[/bold red]")
    for collision in collisions:
        console.print(
            f"- [red]'{collision.name}'[/red] in [cyan]{collision.path1}[/cyan] and [cyan]{collision.path2}[/cyan]"
        )
    return console.export_text()


def generate_namespace_representation(paths: List[Path], config: Dict[str, Any]) -> str:
    """
    Generate a text representation of the namespace.
    
    vibelint/namespace.py
    """
    # Return the tree and collision information
    tree = build_namespace_tree_representation(paths, config)
    collision_str = get_namespace_collisions_str(paths, config)
    
    # Format the final output without double-printing
    console = Console(width=100, record=True)
    console.print(tree)
    if collision_str:
        console.print(collision_str)
    
    # Return the captured output
    return console.export_text()


def detect_namespace_collisions(
    paths: List[Path], config: Dict[str, Any]
) -> List[NamespaceCollision]:
    """
    Detect namespace collisions in the given paths.

    vibelint/namespace.py
    """
    # Build the namespace tree
    namespace_tree = _build_namespace_tree(paths, config)
    
    # Get basic collisions from the namespace tree
    collisions = namespace_tree.get_collisions()
    
    # Now check for additional collision types
    # 1. Find all init files to check for import/module collisions
    init_files = []
    python_modules = {}
    
    for path in paths:
        if path.is_file():
            if path.name == "__init__.py":
                init_files.append(path)
            elif path.suffix == ".py":
                python_modules[path.stem] = path
        elif path.is_dir():
            for file_path in path.rglob("*.py"):
                if file_path.name == "__init__.py":
                    init_files.append(file_path)
                else:
                    python_modules[file_path.stem] = file_path
    
    # 2. For each init file, check for module/import collisions
    for init_file in init_files:
        package_dir = init_file.parent
        import_map, imported_modules, all_names = _extract_imports_and_all(init_file)
        
        # Check for name conflicts between imports and sibling modules
        for module_name, module_path in python_modules.items():
            # Only consider modules in the same directory as this __init__.py
            if module_path.parent != package_dir:
                continue
                
            # Check if this module name conflicts with an imported name
            if module_name in import_map:
                collisions.append(
                    NamespaceCollision(
                        name=module_name,
                        path1=module_path,
                        path2=init_file,
                        collision_type=CollisionType.HARD
                    )
                )
                
        # Check for duplicate names in __all__
        name_counts = {}
        for name in all_names:
            if name not in name_counts:
                name_counts[name] = 0
            name_counts[name] += 1
            
        for name, count in name_counts.items():
            if count > 1:
                collisions.append(
                    NamespaceCollision(
                        name=name,
                        path1=init_file,
                        path2=init_file,  # Same file for duplicates in __all__
                        collision_type=CollisionType.HARD
                    )
                )
        
        # Check if any name in __all__ appears as both an import and a module
        for name in all_names:
            # Check if this name is both a module file and imported
            module_path = package_dir / f"{name}.py"
            if module_path.exists() and name in import_map:
                collisions.append(
                    NamespaceCollision(
                        name=name,
                        path1=module_path,
                        path2=init_file,
                        collision_type=CollisionType.HARD
                    )
                )

    return collisions


def _extract_class_inheritance(file_path: Path, module_path: List[str]) -> List[Tuple[str, List[str]]]:
    """
    Extract class inheritance information from a Python file.
    
    Returns a list of tuples (class_name, [parent_classes])
    """
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        classes = []
        module = ast.parse(content)

        for node in ast.walk(module):
            if isinstance(node, ast.ClassDef):
                class_name = node.name
                parent_classes = []
                
                for base in node.bases:
                    if isinstance(base, ast.Name):
                        parent_classes.append(base.id)
                    elif isinstance(base, ast.Attribute):
                        # Handle cases like 'module.Class'
                        attr_parts = []
                        current = base
                        
                        while isinstance(current, ast.Attribute):
                            attr_parts.append(current.attr)
                            current = current.value
                            
                        if isinstance(current, ast.Name):
                            attr_parts.append(current.id)
                            parent_classes.append(".".join(reversed(attr_parts)))
                
                classes.append((class_name, parent_classes))
        
        return classes
    except Exception:
        # If we can't parse the file, return an empty list
        return []


def detect_soft_member_collisions(
    paths: List[Path], config: Dict[str, Any], use_inheritance_check: bool = True
) -> List[NamespaceCollision]:
    """
    Find member names that appear in multiple modules without inheritance relationships.
    
    These are "soft collisions" - they don't break Python but can confuse humans and LLMs.
    """
    # First, build the namespace tree
    namespace_tree = _build_namespace_tree(paths, config)
    
    # Track all member definitions and their locations
    member_definitions: Dict[str, List[Tuple[Path, List[str]]]] = {}
    
    # Track inheritance relationships if needed
    inheritance_tracker = ClassInheritanceTracker() if use_inheritance_check else None
    
    def traverse_for_members(node: NamespaceNode, module_path: List[str]) -> None:
        """Traverse the namespace tree and collect member definitions."""
        # Process this node's members
        for member_name, file_path in node.members.items():
            if member_name not in member_definitions:
                member_definitions[member_name] = []
            member_definitions[member_name].append((file_path, module_path))
            
        # Process children
        for child_name, child_node in node.children.items():
            # Skip "__init__" since it's a special case
            if child_name == "__init__":
                continue
                
            # Add this child to the module path when traversing
            new_path = module_path + [child_name]
            traverse_for_members(child_node, new_path)
            
            # If we're tracking inheritance, extract class information
            if use_inheritance_check and inheritance_tracker and child_node.path and child_node.path.is_file():
                for class_name, parents in _extract_class_inheritance(child_node.path, new_path):
                    inheritance_tracker.add_class(class_name, parents, child_node.path, new_path)
    
    # Start traversal from the root
    traverse_for_members(namespace_tree, [])
    
    # Find soft collisions
    soft_collisions: List[NamespaceCollision] = []
    
    for member_name, locations in member_definitions.items():
        if len(locations) <= 1:
            continue
            
        # Check all pairs of locations
        for i in range(len(locations)):
            file_path1, module_path1 = locations[i]
            
            for j in range(i + 1, len(locations)):
                file_path2, module_path2 = locations[j]
                
                # Skip comparing a member to itself (same file)
                if file_path1 == file_path2:
                    continue
                
                # If inheritance checking is enabled and we find these are related by inheritance, it's not a collision
                is_related = False
                if use_inheritance_check and inheritance_tracker:
                    qualified_name1 = ".".join(module_path1)
                    qualified_name2 = ".".join(module_path2)
                    is_related = inheritance_tracker.is_related_through_inheritance(qualified_name1, qualified_name2)
                
                if not is_related:
                    soft_collisions.append(
                        NamespaceCollision(
                            name=member_name,
                            path1=file_path1,
                            path2=file_path2,
                            collision_type=CollisionType.SOFT
                        )
                    )
    
    return soft_collisions


def get_soft_collisions_str(paths: List[Path], config: Dict[str, Any]) -> str:
    """
    Get a formatted string of soft namespace collisions if any exist.
    
    vibelint/namespace.py
    """
    # Detect soft collisions
    soft_collisions = detect_soft_member_collisions(paths, config)
    
    if not soft_collisions:
        return ""
        
    # Format collisions as a string
    console = Console(width=100, record=True)
    console.print("\n[bold yellow]Soft Namespace Collisions:[/bold yellow]")
    console.print("[dim](These don't break Python but may confuse humans and LLMs)[/dim]")
    
    for collision in soft_collisions:
        console.print(
            f"- [yellow]'{collision.name}'[/yellow] in [cyan]{collision.path1}[/cyan] and [cyan]{collision.path2}[/cyan]"
        )
    return console.export_text()


def get_files_in_namespace_order(namespace_tree: NamespaceNode) -> List[Path]:
    """
    Get all Python files from the namespace tree in a logical order.
    
    Args:
        namespace_tree: The namespace tree root node
        
    Returns:
        List of file paths ordered by namespace hierarchy
    """
    files = []
    visited = set()
    
    def traverse(node: NamespaceNode):
        # First add the node's file if it exists
        if node.file_path and node.file_path not in visited:
            files.append(node.file_path)
            visited.add(node.file_path)
            
        # Then traverse children in alphabetical order
        for name in sorted(node.children.keys()):
            traverse(node.children[name])
    
    traverse(namespace_tree)
    return files

```

### src/vibelint/report.py

```python
"""
Report generation functionality for vibelint.

vibelint/report.py
"""

from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime

from rich.console import Console

from .lint import LintRunner
from .namespace import (
    build_namespace_tree_representation,
    detect_namespace_collisions,
    detect_soft_member_collisions,
    get_files_in_namespace_order,
    _build_namespace_tree  # Import the internal function directly
)
from .utils import find_package_root

console = Console()

def generate_markdown_report(
    target_paths: List[Path],
    output_dir: Path,
    config: Dict[str, Any],
    check_only: bool = True,
    include_vcs_hooks: bool = False,
    ignore_inheritance: bool = False
) -> Path:
    """
    Generate a comprehensive markdown report of linting results, namespace structure,
    and file contents.
    
    Args:
        target_paths: List of paths to analyze
        output_dir: Directory where the report will be saved
        config: Configuration dictionary
        check_only: Only check for issues without suggesting fixes
        include_vcs_hooks: Whether to include version control hooks
        ignore_inheritance: Whether to ignore inheritance when checking for soft collisions
        
    Returns:
        Path to the generated report file
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_filename = f"vibelint_report_{timestamp}.md"
    report_path = output_dir / report_filename
    
    # Run linting
    lint_runner = LintRunner(
        config=config,
        check_only=True,  # Always check only for reports
        skip_confirmation=True,
        include_vcs_hooks=include_vcs_hooks,
    )
    
    console.print("[bold blue]Running linting checks...[/bold blue]")
    lint_runner.run(target_paths)
    
    # Build namespace tree representation for display
    console.print("[bold blue]Building namespace structure...[/bold blue]")
    tree_repr = build_namespace_tree_representation(target_paths, config)
    
    # Get the actual namespace tree node for file ordering
    # Use _build_namespace_tree directly instead of trying to extract from tree_repr
    namespace_tree = _build_namespace_tree(target_paths, config, include_vcs_hooks)
    
    # Detect collisions
    console.print("[bold blue]Detecting namespace collisions...[/bold blue]")
    hard_collisions = detect_namespace_collisions(target_paths, config)
    soft_collisions = detect_soft_member_collisions(
        target_paths, config, use_inheritance_check=not ignore_inheritance
    )
    
    # Generate report
    console.print("[bold blue]Generating markdown report...[/bold blue]")
    with open(report_path, "w", encoding="utf-8") as f:
        # Report header
        package_roots = [find_package_root(path) for path in target_paths]
        package_names = []
        for p in package_roots:
            if p is not None and p.exists() and p.name:
                package_names.append(p.name)
        
        f.write("# vibelint Report\n\n")
        f.write(f"*Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n")
        f.write(f"**Project(s):** {', '.join(package_names) or 'Unknown'}\n\n")
        f.write(f"**Paths analyzed:** {', '.join(str(p) for p in target_paths)}\n\n")
        
        # Table of Contents
        f.write("## Table of Contents\n\n")
        f.write("1. [Summary](#summary)\n")
        f.write("2. [Linting Results](#linting-results)\n")
        f.write("3. [Namespace Structure](#namespace-structure)\n")
        f.write("4. [Namespace Collisions](#namespace-collisions)\n")
        f.write("5. [File Contents](#file-contents)\n\n")
        
        # Summary section
        f.write("## Summary\n\n")
        f.write("| Metric | Count |\n")
        f.write("|--------|-------|\n")
        f.write(f"| Files analyzed | {len(lint_runner.results)} |\n")
        f.write(f"| Files with errors | {lint_runner.files_with_errors} |\n")
        f.write(f"| Files with warnings | {lint_runner.files_with_warnings} |\n")
        f.write(f"| Hard namespace collisions | {len(hard_collisions)} |\n")
        f.write(f"| Soft namespace collisions | {len(soft_collisions)} |\n\n")
        
        # Linting Results
        f.write("## Linting Results\n\n")
        if not lint_runner.results:
            f.write("*No linting results available.*\n\n")
        else:
            f.write("| File | Errors | Warnings |\n")
            f.write("|------|--------|----------|\n")
            for result in lint_runner.results:
                if result.has_issues:
                    errors = "; ".join(result.errors) or "None"
                    warnings = "; ".join(result.warnings) or "None"
                    f.write(f"| `{result.file_path}` | {errors} | {warnings} |\n")
            f.write("\n")
        
        # Namespace Structure
        f.write("## Namespace Structure\n\n")
        f.write("```\n")
        f.write(str(tree_repr))
        f.write("\n```\n\n")
        
        # Namespace Collisions
        f.write("## Namespace Collisions\n\n")
        
        # Hard collisions
        f.write("### Hard Collisions\n\n")
        if not hard_collisions:
            f.write("*No hard collisions detected.*\n\n")
        else:
            f.write("These collisions can break Python imports:\n\n")
            f.write("| Name | Path 1 | Path 2 |\n")
            f.write("|------|--------|--------|\n")
            for collision in hard_collisions:
                f.write(f"| `{collision.name}` | {collision.path1} | {collision.path2} |\n")
            f.write("\n")
        
        # Soft collisions
        f.write("### Soft Collisions\n\n")
        if not soft_collisions:
            f.write("*No soft collisions detected.*\n\n") 
        else:
            f.write("These don't break Python but may confuse humans and LLMs:\n\n")
            f.write("| Name | Path 1 | Path 2 |\n")
            f.write("|------|--------|--------|\n")
            for collision in soft_collisions:
                f.write(f"| `{collision.name}` | {collision.path1} | {collision.path2} |\n")
            f.write("\n")
        
        # File Contents
        f.write("## File Contents\n\n")
        f.write("Files are ordered by their position in the namespace hierarchy.\n\n")
        
        # Get all Python files from the namespace tree in a logical order
        python_files = get_files_in_namespace_order(namespace_tree)
        
        for file_path in python_files:
            if file_path.is_file() and file_path.suffix == '.py':
                rel_path = get_relative_path(file_path, target_paths)
                f.write(f"### {rel_path}\n\n")
                try:
                    with open(file_path, 'r', encoding='utf-8') as code_file:
                        content = code_file.read()
                        f.write("```python\n")
                        f.write(content)
                        f.write("\n```\n\n")
                except Exception as e:
                    f.write(f"*Error reading file: {str(e)}*\n\n")
    
    return report_path


def get_relative_path(file_path: Path, base_paths: List[Path]) -> str:
    """
    Get the relative path of a file from the closest base path.
    
    Args:
        file_path: The file path to get the relative path for
        base_paths: List of base paths to use as reference
        
    Returns:
        The relative path as a string
    """
    shortest_path = None
    
    for base_path in base_paths:
        try:
            rel_path = file_path.relative_to(base_path)
            if shortest_path is None or len(str(rel_path)) < len(str(shortest_path)):
                shortest_path = rel_path
        except ValueError:
            continue
            
    return str(shortest_path) if shortest_path else str(file_path)
```

### src/vibelint/utils.py

```python
"""
Utility functions for vibelint.

vibelint/utils.py
"""

from pathlib import Path
from typing import Dict, Any, Optional
import fnmatch


def find_package_root(path: Path) -> Optional[Path]:
    """
    Find the package root directory by looking for a setup.py, pyproject.toml, or __init__.py file.
    
    Args:
        path: Path to start searching from
        
    Returns:
        The package root directory, or None if not found
    """
    if path.is_file():
        path = path.parent
    
    current = path
    
    # First try to find setup.py or pyproject.toml
    while current.parent != current:
        if (current / "setup.py").exists() or (current / "pyproject.toml").exists():
            return current
        current = current.parent
    
    # If not found, try looking for the top-level __init__.py
    current = path
    while current.parent != current:
        if not (current / "__init__.py").exists() and (current.parent / "__init__.py").exists():
            return current
        if not (current.parent / "__init__.py").exists():
            # Return the last directory that contained __init__.py
            return current
        current = current.parent
    
    # If no package structure found, return the original directory
    return path


def count_python_files(
    directory: Path, config: Dict[str, Any], include_vcs_hooks: bool = False
) -> int:
    """
    Count the number of Python files in a directory that match the configuration.

    vibelint/utils.py
    """
    count = 0

    for include_glob in config["include_globs"]:
        for file_path in directory.glob(include_glob):
            # Skip if it's not a file or not a Python file
            if not file_path.is_file() or file_path.suffix != ".py":
                continue

            # Skip VCS directories unless explicitly included
            if not include_vcs_hooks and any(
                part.startswith(".") and part in {".git", ".hg", ".svn"}
                for part in file_path.parts
            ):
                continue

            # Check exclude patterns
            if any(
                fnmatch.fnmatch(str(file_path), str(directory / exclude_glob))
                for exclude_glob in config["exclude_globs"]
            ):
                continue

            count += 1

    return count
```

### src/vibelint/validators/ValidationResult.py

```python
def break_vibelint():
    """
    This function is used to break the vibelint process.
    """
    raise Exception("Vibelint process has been broken.")
```

### src/vibelint/validators/docstring.py

```python
"""
Validator for Python module docstrings.

vibelint/validators/docstring.py
"""

import re
import os
from typing import List, Optional


class ValidationResult:
    """
    Class to store the result of a validation.

    vibelint/validators/docstring.py
    """

    def __init__(self):
        self.errors: List[str] = []
        self.warnings: List[str] = []
        self.line_number: int = -1
        self.needs_fix: bool = False
        self.module_docstring: Optional[str] = None

    def has_issues(self) -> bool:
        """Check if there are any issues."""
        return len(self.errors) > 0 or len(self.warnings) > 0


def validate_module_docstring(
    content: str, relative_path: str, docstring_regex: str
) -> ValidationResult:
    """
    Validate the module docstring in a Python file.

    vibelint/validators/docstring.py
    """
    result = ValidationResult()
    lines = content.splitlines()

    # Skip shebang and encoding cookie if present
    line_index = 0
    if len(lines) > line_index and lines[line_index].startswith("#!"):
        line_index += 1
    if len(lines) > line_index and lines[line_index].startswith("# -*-"):
        line_index += 1

    # Skip blank lines
    while line_index < len(lines) and not lines[line_index].strip():
        line_index += 1

    # Check for docstring
    docstring_start = None
    docstring_end = None
    docstring_lines = []

    # Try to find the docstring
    for i in range(line_index, min(line_index + 10, len(lines))):
        line = lines[i].strip()
        if line.startswith('"""'):
            docstring_start = i
            # Single line docstring
            if line.endswith('"""') and len(line) > 6:
                docstring_end = i
                docstring_lines = [line[3:-3].strip()]
                break

            # Handle multi-line docstring
            first_content_line = None
            if line == '"""':
                # Triple quotes on their own line - content starts on next line
                first_content_line = i + 1
            else:
                # Content starts on same line as opening quotes
                first_content_line = i
                docstring_lines.append(line[3:].strip())

            # Find the end of the docstring
            for j in range(first_content_line, len(lines)):
                current_line = lines[j].strip()
                # Look for a line that ends with triple quotes or is just triple quotes
                if current_line == '"""' or current_line.endswith('"""'):
                    docstring_end = j

                    # If we didn't already add the first line (when quotes were on their own line)
                    if first_content_line > i:
                        # Add lines between opening quote and closing quote
                        docstring_lines.extend(
                            lines[k].strip()
                            for k in range(first_content_line, j)
                            if lines[k].strip()
                        )
                    else:
                        # Add lines after the first content line
                        docstring_lines.extend(
                            lines[k].strip()
                            for k in range(i + 1, j)
                            if lines[k].strip()
                        )

                    # Add content from the last line if it has content before the closing quotes
                    if current_line != '"""':
                        content_part = current_line.split('"""')[0].strip()
                        if content_part:
                            docstring_lines.append(content_part)
                    break
            break

    # If no docstring found or incomplete docstring
    if docstring_start is None or docstring_end is None:
        result.errors.append("Module docstring missing or incomplete")
        result.line_number = line_index
        result.needs_fix = True
        return result

    # Store the docstring for potential fixes
    result.module_docstring = "\n".join(docstring_lines)
    result.line_number = docstring_start

    # Validate docstring content
    if not docstring_lines:
        result.errors.append("Empty module docstring")
        result.needs_fix = True
        return result

    # Check first line format (capitalized sentence ending in period)
    # Get the first non-empty line
    first_content = next((line for line in docstring_lines if line), "")
    if not re.match(docstring_regex, first_content):
        result.errors.append(
            f"First line of docstring should match regex: {docstring_regex}"
        )
        result.needs_fix = True

    # Check for relative path in docstring
    path_found = False

    # Extract the package-relative path from the full path
    package_path = relative_path

    # Handle files in project root differently
    if os.path.basename(relative_path) == relative_path:
        # It's already just a filename with no directories, so use as is
        package_path = relative_path
    elif "/src/" in relative_path:
        package_path = relative_path.split("/src/")[-1]
    elif "/Users/" in relative_path:
        # Extract just the project path
        parts = relative_path.split("/")
        if "vibelint" in parts:
            idx = parts.index("vibelint")
            # Handle setup.py and other files in project root
            if idx + 1 >= len(parts) or parts[idx + 1] in [
                "setup.py",
                "README.md",
                "pyproject.toml",
            ]:
                package_path = parts[-1]  # Just use the filename
            elif idx + 1 < len(parts) and parts[idx + 1] == "src":
                package_path = "/".join(parts[idx + 2 :])
            else:
                package_path = "/".join(
                    parts[idx + 1 :]
                )  # Don't include vibelint itself

    # Check for either the full path or the package-relative path
    for line in docstring_lines:
        if relative_path in line or package_path in line:
            path_found = True
            break

    if not path_found:
        result.errors.append(
            f"Docstring should include the relative path: {package_path}"
        )
        result.needs_fix = True

    return result


def fix_module_docstring(
    content: str, result: ValidationResult, relative_path: str
) -> str:
    """
    Fix module docstring issues in a Python file.

    vibelint/validators/docstring.py
    """
    # Extract the package-relative path with the same logic as in validate_module_docstring
    package_path = relative_path

    # Handle files in project root differently
    if os.path.basename(relative_path) == relative_path:
        # It's already just a filename with no directories, so use as is
        package_path = relative_path
    elif "/src/" in relative_path:
        package_path = relative_path.split("/src/")[-1]
    elif "/Users/" in relative_path:
        parts = relative_path.split("/")
        if "vibelint" in parts:
            idx = parts.index("vibelint")
            # Handle setup.py and other files in project root
            if idx + 1 >= len(parts) or parts[idx + 1] in [
                "setup.py",
                "README.md",
                "pyproject.toml",
            ]:
                package_path = parts[-1]  # Just use the filename
            elif idx + 1 < len(parts) and parts[idx + 1] == "src":
                package_path = "/".join(parts[idx + 2 :])
            else:
                package_path = "/".join(
                    parts[idx + 1 :]
                )  # Don't include vibelint itself

    if not result.needs_fix:
        return content

    lines = content.splitlines()

    # If there's no docstring, create a new one
    if result.module_docstring is None:
        # Get the module name from the relative path
        module_name = os.path.basename(relative_path).replace(".py", "")

        # Create a docstring with preferred style (quotes on their own lines)
        docstring = [
            '"""',
            f"{module_name.replace('_', ' ').title()} module.",
            "",
            f"{package_path}",
            '"""',
        ]

        # Insert the docstring at the appropriate position
        for i, line in enumerate(docstring):
            lines.insert(result.line_number + i, line)
    else:
        # Modify the existing docstring
        existing_docstring = result.module_docstring.splitlines()

        # Fix the first line if needed
        if existing_docstring:
            first_content = existing_docstring[0]
            if not re.match(r"^[A-Z].+\.$", first_content):
                # Capitalize first letter and ensure it ends with a period
                if first_content:
                    first_content = first_content[0].upper() + first_content[1:]
                    if not first_content.endswith("."):
                        first_content += "."
                    existing_docstring[0] = first_content

        # Add relative path if missing
        path_found = False
        for i, line in enumerate(existing_docstring):
            if relative_path in line or package_path in line:
                path_found = True
                break

        if not path_found:
            # Add an empty line before the path if there isn't one already
            if existing_docstring and existing_docstring[-1]:
                existing_docstring.append("")
            existing_docstring.append(package_path)

        # Reconstruct the docstring
        docstring_text = "\n".join(existing_docstring)

        # Replace the old docstring
        start_idx = result.line_number
        end_idx = start_idx

        # Find the end of the old docstring
        in_docstring = False
        for i in range(start_idx, len(lines)):
            line = lines[i].strip()
            if line.startswith('"""') and not in_docstring:
                in_docstring = True
                if line.endswith('"""') and len(line) > 6:
                    # Single line docstring
                    end_idx = i
                    break
            elif (line == '"""' or line.endswith('"""')) and in_docstring:
                end_idx = i
                break

        # If it's a single-line docstring, convert to multi-line with preferred style
        new_docstring_lines = ['"""']
        docstring_lines = docstring_text.splitlines()
        new_docstring_lines.extend(docstring_lines)
        new_docstring_lines.append('"""')

        # Replace the old docstring lines with the new ones
        lines = lines[:start_idx] + new_docstring_lines + lines[end_idx + 1 :]

    return "\n".join(lines) + ("\n" if content.endswith("\n") else "")

```

### src/vibelint/validators/encoding.py

```python
"""
Validator for Python encoding cookies.

vibelint/validators/encoding.py
"""

import re
from typing import List


class ValidationResult:
    """
    Class to store the result of a validation.

    vibelint/validators/encoding.py
    """

    def __init__(self):
        self.errors: List[str] = []
        self.warnings: List[str] = []
        self.line_number: int = -1
        self.needs_fix: bool = False

    def has_issues(self) -> bool:
        """Check if there are any issues."""
        return len(self.errors) > 0 or len(self.warnings) > 0


def validate_encoding_cookie(content: str) -> ValidationResult:
    """
    Validate the encoding cookie in a Python file.

    vibelint/validators/encoding.py
    """
    result = ValidationResult()
    lines = content.splitlines()

    # Check for encoding cookie pattern
    encoding_pattern = r"^# -\*- coding: (.+) -\*-$"

    # Determine where to look for the encoding cookie
    start_line = 0
    # If there's a shebang, look for the encoding cookie on the second line
    if len(lines) > 0 and lines[0].startswith("#!"):
        start_line = 1

    # Check the encoding cookie
    if start_line < len(lines):
        match = re.match(encoding_pattern, lines[start_line])
        if match:
            encoding = match.group(1)
            result.line_number = start_line

            # Check if the encoding is utf-8
            if encoding.lower() != "utf-8":
                result.errors.append(
                    f"Invalid encoding cookie: {encoding}. Use 'utf-8' instead."
                )
                result.needs_fix = True
        else:
            # No encoding cookie, but we don't require one
            pass

    return result


def fix_encoding_cookie(content: str, result: ValidationResult) -> str:
    """
    Fix encoding cookie issues in a Python file.

    vibelint/validators/encoding.py
    """
    if not result.needs_fix:
        return content

    lines = content.splitlines()

    # If there's an invalid encoding cookie, replace it
    if result.line_number >= 0:
        lines[result.line_number] = "# -*- coding: utf-8 -*-"

    return "\n".join(lines) + ("\n" if content.endswith("\n") else "")

```

### src/vibelint/validators/shebang.py

```python
"""
Validator for Python shebangs.

vibelint/validators/shebang.py
"""

from typing import List


class ValidationResult:
    """
    Class to store the result of a validation.

    vibelint/validators/shebang.py
    """

    def __init__(self):
        self.errors: List[str] = []
        self.warnings: List[str] = []
        self.line_number: int = 0
        self.needs_fix: bool = False

    def has_issues(self) -> bool:
        """Check if there are any issues."""
        return len(self.errors) > 0 or len(self.warnings) > 0


def validate_shebang(
    content: str, is_script: bool, allowed_shebangs: List[str]
) -> ValidationResult:
    """
    Validate the shebang in a Python file.

    vibelint/validators/shebang.py
    """
    result = ValidationResult()
    lines = content.splitlines()

    # Check if there's a shebang line
    has_shebang = len(lines) > 0 and lines[0].startswith("#!")

    if has_shebang:
        result.line_number = 0
        shebang_line = lines[0]

        # Check if script has __main__ block
        if not is_script:
            result.errors.append(
                f"File has a shebang ({shebang_line}) but no '__main__' block. "
                "Shebangs should only be used in executable scripts."
            )
            result.needs_fix = True
        # Check if shebang is in the allowed list
        elif shebang_line not in allowed_shebangs:
            result.errors.append(
                f"Invalid shebang: {shebang_line}. "
                f"Allowed shebangs: {', '.join(allowed_shebangs)}"
            )
            result.needs_fix = True
    else:
        # If the file is a script, it should have a shebang
        if is_script:
            result.warnings.append(
                "Script with '__main__' block should have a shebang line."
            )
            result.needs_fix = True
            result.line_number = 0  # Insert at the beginning

    return result


def fix_shebang(
    content: str, result: ValidationResult, is_script: bool, preferred_shebang: str
) -> str:
    """
    Fix shebang issues in a Python file.

    vibelint/validators/shebang.py
    """
    if not result.needs_fix:
        return content

    lines = content.splitlines()

    # If there's already a shebang line
    if result.line_number == 0 and len(lines) > 0 and lines[0].startswith("#!"):
        # Remove it if the file is not a script
        if not is_script:
            lines.pop(0)
        # Replace it with the preferred shebang if it's invalid
        else:
            lines[0] = preferred_shebang
    # Add a shebang if the file is a script and doesn't have one
    elif is_script and (len(lines) == 0 or not lines[0].startswith("#!")):
        lines.insert(0, preferred_shebang)

    return "\n".join(lines) + ("\n" if content.endswith("\n") else "")

```

### tests/test_docstring.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tests for the docstring validator.

tests/test_docstring.py
"""

import unittest
import re
from vibelint.validators.docstring import (
    validate_module_docstring,
    fix_module_docstring,
)


class DocstringValidatorTests(unittest.TestCase):
    """Test cases for the docstring validator."""

    def test_valid_docstring(self):
        """Test validation of a valid docstring."""
        content = '"""Module example with a valid docstring.\n\npath/to/module.py\n"""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        self.assertFalse(result.has_issues())

    def test_missing_docstring(self):
        """Test validation of a missing docstring."""
        content = 'def hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        self.assertTrue(result.has_issues())
        self.assertTrue(any("docstring missing" in e.lower() for e in result.errors))

    def test_docstring_without_capitalized_first_line(self):
        """Test validation of a docstring without a capitalized first line."""
        content = '"""module example without capitalization.\n\npath/to/module.py\n"""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        self.assertTrue(result.has_issues())
        self.assertTrue(any("first line" in e.lower() for e in result.errors))

    def test_docstring_without_period(self):
        """Test validation of a docstring without a period at the end of the first line."""
        content = '"""Module example without a period\n\npath/to/module.py\n"""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        self.assertTrue(result.has_issues())
        self.assertTrue(any("first line" in e.lower() for e in result.errors))

    def test_docstring_without_path(self):
        """Test validation of a docstring without the module path."""
        content = '"""Module example with a valid first line.\n\nThis is missing the module path.\n"""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        self.assertTrue(result.has_issues())
        self.assertTrue(any("path" in e.lower() for e in result.errors))

    def test_single_line_docstring(self):
        """Test validation of a single-line docstring."""
        content = '"""Module example with a single-line docstring including path/to/module.py."""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        self.assertFalse(result.has_issues())

    def test_docstring_after_shebang_and_encoding(self):
        """Test validation of a docstring after shebang and encoding."""
        content = '#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n"""Module example.\n\npath/to/module.py\n"""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        self.assertFalse(result.has_issues())

    def test_fix_missing_docstring(self):
        """Test fixing a missing docstring."""
        content = 'def hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        fixed = fix_module_docstring(content, result, "path/to/module.py")
        # Check if the fixed content contains the expected docstring elements
        self.assertIn('"""', fixed)
        self.assertIn("path/to/module.py", fixed)
        self.assertIn("Module", fixed)  # Should have capitalized module name

    def test_fix_docstring_first_line(self):
        """Test fixing a docstring's first line."""
        content = '"""module example without capitalization or period\n\npath/to/module.py\n"""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        fixed = fix_module_docstring(content, result, "path/to/module.py")
        # Check if the first content line is properly capitalized and has a period
        lines = fixed.split("\n")
        # In multi-line docstrings, the first line is just the opening quotes,
        # and the actual content starts on the second line
        content_line = (
            lines[1] if lines[0].strip() == '"""' else lines[0].replace('"""', "", 1)
        )
        self.assertTrue(re.match(r"^[A-Z].+\.$", content_line.strip()))

    def test_fix_docstring_add_path(self):
        """Test fixing a docstring by adding the module path."""
        content = '"""Module example with a valid first line.\n\nThis is missing the module path.\n"""\n\ndef hello():\n    print("Hello")'
        result = validate_module_docstring(content, "path/to/module.py", r"^[A-Z].+\.$")
        fixed = fix_module_docstring(content, result, "path/to/module.py")
        # Check if the path was added to the docstring
        self.assertIn("path/to/module.py", fixed)


if __name__ == "__main__":
    unittest.main()

```

### tests/test_encoding.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tests for the encoding cookie validator.

tests/test_encoding.py
"""

import unittest
from vibelint.validators.encoding import validate_encoding_cookie, fix_encoding_cookie


class EncodingCookieValidatorTests(unittest.TestCase):
    """Test cases for the encoding cookie validator."""

    def test_valid_encoding_cookie(self):
        """Test validation of a valid encoding cookie."""
        content = "# -*- coding: utf-8 -*-\n\ndef hello():\n    print('Hello')"
        result = validate_encoding_cookie(content)
        self.assertFalse(result.has_issues())

    def test_valid_encoding_cookie_after_shebang(self):
        """Test validation of a valid encoding cookie after a shebang."""
        content = "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef hello():\n    print('Hello')"
        result = validate_encoding_cookie(content)
        self.assertFalse(result.has_issues())

    def test_invalid_encoding_cookie(self):
        """Test validation of an invalid encoding cookie."""
        content = "# -*- coding: latin-1 -*-\n\ndef hello():\n    print('Hello')"
        result = validate_encoding_cookie(content)
        self.assertTrue(result.has_issues())
        self.assertTrue(any("Invalid encoding cookie" in e for e in result.errors))

    def test_missing_encoding_cookie(self):
        """Test validation of a missing encoding cookie (which is allowed)."""
        content = "def hello():\n    print('Hello')"
        result = validate_encoding_cookie(content)
        self.assertFalse(result.has_issues())

    def test_fix_invalid_encoding_cookie(self):
        """Test fixing an invalid encoding cookie."""
        content = "# -*- coding: latin-1 -*-\n\ndef hello():\n    print('Hello')"
        result = validate_encoding_cookie(content)
        fixed = fix_encoding_cookie(content, result)
        self.assertEqual(
            fixed, "# -*- coding: utf-8 -*-\n\ndef hello():\n    print('Hello')"
        )

    def test_fix_invalid_encoding_cookie_after_shebang(self):
        """Test fixing an invalid encoding cookie after a shebang."""
        content = "#!/usr/bin/env python3\n# -*- coding: latin-1 -*-\n\ndef hello():\n    print('Hello')"
        result = validate_encoding_cookie(content)
        fixed = fix_encoding_cookie(content, result)
        self.assertEqual(
            fixed,
            "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef hello():\n    print('Hello')",
        )


if __name__ == "__main__":
    unittest.main()

```

### tests/test_shebang.py

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tests for the shebang validator.

tests/test_shebang.py
"""

import unittest
from vibelint.validators.shebang import validate_shebang, fix_shebang


class ShebangValidatorTests(unittest.TestCase):
    """Test cases for the shebang validator."""

    def test_valid_shebang_in_script(self):
        """Test validation of a valid shebang in a script."""
        content = (
            "#!/usr/bin/env python3\n\nif __name__ == '__main__':\n    print('Hello')"
        )
        result = validate_shebang(content, True, ["#!/usr/bin/env python3"])
        self.assertFalse(result.has_issues())

    def test_invalid_shebang_in_script(self):
        """Test validation of an invalid shebang in a script."""
        content = "#!/usr/bin/python\n\nif __name__ == '__main__':\n    print('Hello')"
        result = validate_shebang(content, True, ["#!/usr/bin/env python3"])
        self.assertTrue(result.has_issues())
        self.assertTrue(any("Invalid shebang" in e for e in result.errors))

    def test_shebang_in_non_script(self):
        """Test validation of a shebang in a non-script file."""
        content = "#!/usr/bin/env python3\n\ndef hello():\n    print('Hello')"
        result = validate_shebang(content, False, ["#!/usr/bin/env python3"])
        self.assertTrue(result.has_issues())
        self.assertTrue(any("no '__main__' block" in e for e in result.errors))

    def test_missing_shebang_in_script(self):
        """Test validation of a missing shebang in a script."""
        content = "if __name__ == '__main__':\n    print('Hello')"
        result = validate_shebang(content, True, ["#!/usr/bin/env python3"])
        self.assertTrue(result.has_issues())
        self.assertTrue(any("should have a shebang" in w for w in result.warnings))

    def test_fix_shebang_in_script(self):
        """Test fixing a shebang in a script."""
        content = "#!/usr/bin/python\n\nif __name__ == '__main__':\n    print('Hello')"
        result = validate_shebang(content, True, ["#!/usr/bin/env python3"])
        fixed = fix_shebang(content, result, True, "#!/usr/bin/env python3")
        self.assertEqual(
            fixed,
            "#!/usr/bin/env python3\n\nif __name__ == '__main__':\n    print('Hello')",
        )

    def test_fix_missing_shebang_in_script(self):
        """Test fixing a missing shebang in a script."""
        content = "if __name__ == '__main__':\n    print('Hello')"
        result = validate_shebang(content, True, ["#!/usr/bin/env python3"])
        fixed = fix_shebang(content, result, True, "#!/usr/bin/env python3")
        self.assertEqual(
            fixed,
            "#!/usr/bin/env python3\nif __name__ == '__main__':\n    print('Hello')",
        )

    def test_fix_remove_shebang_in_non_script(self):
        """Test removing a shebang from a non-script file."""
        content = "#!/usr/bin/env python3\n\ndef hello():\n    print('Hello')"
        result = validate_shebang(content, False, ["#!/usr/bin/env python3"])
        fixed = fix_shebang(content, result, False, "#!/usr/bin/env python3")
        self.assertEqual(fixed, "\ndef hello():\n    print('Hello')")


if __name__ == "__main__":
    unittest.main()

```

